//go:generate go run ./generate_commands.go
package main

import (
	"blue/commands"
	"encoding/json"
	"fmt"
	"io/fs"
	"io/ioutil"
	"path/filepath"
	"strings"
)

var typeInfo = `const (
	TypeSystem Header = iota * (1 << 5)
	TypeDB
	TypeNumber
	TypeString
	TypeList
	TypeSet
	TypeJson
)

`

var typeMap = map[string]string{
	"system": "TypeSystem",
	"db":     "TypeDB",
	"number": "TypeNumber",
	"string": "TypeString",
	"list":   "TypeList",
	"set":    "TypeSet",
	"json":   "TypeJson",
}

func main() {
	// 读取 JSON 文件
	files := []string{} // 添加更多文件名

	err := filepath.Walk("../commands", func(path string, info fs.FileInfo, err error) error {
		if filepath.Ext(path) != ".json" {
			return nil
		}

		abs, err := filepath.Abs(path)
		if err != nil {
			return nil
		}

		files = append(files, abs)
		return nil
	})
	if err != nil {
		fmt.Println("Error walking directory:", err)
		return
	}

	var cmds []commands.Cmd
	for _, file := range files {
		data, err := ioutil.ReadFile(file)
		if err != nil {
			fmt.Println("Error reading file:", err)
			return
		}

		// 解析 JSON 数据
		var fileCommands commands.Cmd
		err = json.Unmarshal(data, &fileCommands)
		if err != nil {
			fmt.Println("Error unmarshalling JSON:", err)
			return
		}

		cmds = append(cmds, fileCommands)
	}

	// 生成 Go 代码
	var code strings.Builder
	code.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	code.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	code.WriteString("// Code generated by go generate; DO NOT EDIT.\n\n")
	code.WriteString("package bsp\n\n")
	code.WriteString("import \"blue/commands\"\n\n")
	code.WriteString(fmt.Sprintf("const cmdLen = %d\n\n", len(cmds)))

	for k, v := range typeMap {
		writeType(&code, cmds, k, v)
	}

	code.WriteString("var HandleMap = [...]string{\n")
	for _, cmd := range cmds {
		constName := strings.ToUpper(strings.ReplaceAll(cmd.Name, " ", "_"))
		code.WriteString(fmt.Sprintf("\t%s: \"%s\",\n", constName, constName))
	}
	code.WriteString("}\n\n")

	code.WriteString("var HandleMap2 = map[string]Header{\n")
	for _, cmd := range cmds {
		constName := strings.ToUpper(strings.ReplaceAll(cmd.Name, " ", "_"))
		code.WriteString(fmt.Sprintf("\t\"%s\": %s,\n", constName, constName))
	}
	code.WriteString("}\n\n")

	code.WriteString("var CommandsMap = [...]commands.Cmd{\n")
	for _, cmd := range cmds {
		constName := strings.ToUpper(strings.ReplaceAll(cmd.Name, " ", "_"))
		code.WriteString(
			fmt.Sprintf("\t%s: {Name:\"%s\",Summary: \"%s\", Group: \"%s\", Arity: %d, Key: \"%s\", Value: \"%s\", Arguments: %#v},\n",
				constName, constName, cmd.Summary, cmd.Group, cmd.Arity, cmd.Key, cmd.Value, cmd.Arguments))
	}
	code.WriteString("}\n\n")

	// 将代码写入文件
	err = ioutil.WriteFile("../bsp/commands.go", []byte(code.String()), 0644)
	if err != nil {
		fmt.Println("Error writing file:", err)
		return
	}

	fmt.Println("Commands generated successfully!")
}

// del Header = 0 + TypeSystem
func writeType(code *strings.Builder, cmds []commands.Cmd, typeName, v string) {
	if len(cmds) == 0 {
		return
	}

	code.WriteString(fmt.Sprintf("// %s -----------------------------\n", typeName))
	code.WriteString("const (\n")
	i := 1
	for _, cmd := range cmds {
		if cmd.Group == typeName {
			constName := strings.ToUpper(strings.ReplaceAll(cmd.Name, " ", "_"))
			code.WriteString(fmt.Sprintf("\t%s Header = %d + %s\n", constName, i, v))
			i++
		}
	}
	code.WriteString(")\n\n")
}
